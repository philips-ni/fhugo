#+hugo_base_dir: ../../
# -*- mode: org; coding: utf-8; -*-
* Header Information                                               :noexport:
#+LaTeX_CLASS_OPTIONS: [11pt]
#+LATEX_HEADER: \usepackage{helvetica}
#+LATEX_HEADER: \setlength{\textwidth}{5.1in} % set width of text portion
#+LATEX_HEADER: \usepackage{geometry}
#+TITLE:     LeetCode tips
#+AUTHOR:    Fei Ni
#+EMAIL:     fei.ni@helix.com
#+DATE:      2022-04-25
#+HUGO_CATEGORIES: helix
#+HUGO_tags: helix
#+hugo_auto_set_lastmod: t
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS:   ^:{}
#+INFOJS_OPT: view:nil toc:nil ltoc:nil mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+HTML_HEAD: <link rel="stylesheet" href="org.css" type="text/css"/>
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

#+STARTUP: hidestars

#+STARTUP: overview   (or: showall, content, showeverything)
http://orgmode.org/org.html#Visibility-cycling  info:org#Visibility cycling

#+TODO: TODO(t) NEXT(n) STARTED(s) WAITING(w@/!) SOMEDAY(S!) | DONE(d!/!) CANCELLED(c@/!)
http://orgmode.org/org.html#Per_002dfile-keywords  info:org#Per-file keywords

#+TAGS: important(i) private(p)
#+TAGS: @HOME(h) @OFFICE(o)
http://orgmode.org/org.html#Setting-tags  info:org#Setting tags

#+NOstartup: beamer
#+NOLaTeX_CLASS: beamer
#+NOLaTeX_CLASS_OPTIONS: [bigger]
#+NOBEAMER_FRAME_LEVEL: 2


# Start from here


* Bit o/p
** set a bit in pos for number
   #+begin_src c++
num |= (1 << pos);
   #+end_src
** unset/clear a bit in pos for number
   #+begin_src c++
num &= (~(1 << pos));
   #+end_src

** Toggling a bit at nth position
   #+begin_src c++
num ^= (1 << pos);
   #+end_src

** Checking if bit at nth position is set or unset:
   #+begin_src c++
bool bit = num & (1<<pos);
   #+end_src

** Stripping off the lowest set bit :
   #+begin_src c++
num = num & (num-1);
   #+end_src
** Getting lowest set bit of a number

   #+begin_src c++
int ret = num & (-num);
   #+end_src
** XOR
   #+begin_src c++
     0^N == N
     N^N == 0
     M^N == N^M
     a^b^a = b
   #+end_src

   #+begin_src python
     '''
     Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.

     You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.



     Example 1:

     Input: nums = [1,2,1,3,2,5]
     Output: [3,5]
     Explanation:  [5, 3] is also a valid answer.
     '''
    from functools import reduce
    class Solution(object):
        def singleNumber(self, nums):
  	  a_xor_b = reduce(lambda x, y: x ^ y, nums)
  	  xor_sum = dict()
  	  for a in nums:
  	      b = a_xor_b ^ a
  	      if b in xor_sum and xor_sum[b] == a:
  		  return [b,a]
  	      xor_sum[a] = b
   #+end_src
   - https://leetcode.com/problems/binary-gap/
   - https://leetcode.com/problems/single-number-iii/
   - https://leetcode.com/problems/decode-xored-permutation/
   - https://emre.me/computer-science/bit-manipulation-tricks/
* String tips
  #+begin_src python
    # check if a string is something like "abcabcabc"
    def repeatedSubstringPattern(self, str):
	return str in (2 * str)[1:-1]
  #+end_src
  #+begin_src python
    def isRotatedFrom(self, s1, s2):
        return s1 in (s2 + s2)
  #+end_src
* Linked List
  #+begin_src python
 class ListNode(object):
     def __init__(self, x):
         self.val = x
         self.next = None
  #+end_src
  #+begin_src c++
 struct ListNode {
     int val;
     ListNode *next;
     ListNode() : val(0), next(nullptr) {}
     ListNode(int x) : val(x), next(nullptr) {}
     ListNode(int x, ListNode *next) : val(x), next(next) {}
 };
  #+end_src
  - Dummy node
  - three points (pre, curr, next)
  - https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/
  - https://leetcode.com/problems/reverse-linked-list/
  - https://leetcode.com/problems/lru-cache/ (hash + linkedList)
  - https://leetcode.com/problems/lfu-cache/
    #+begin_src c++
      list<int> usage;
      //  insert key into the begin of list
      usage.insert(usage.begin(), key);
      // move the node of it to the begin of list
      usage.splice(usage.begin(), usage, it);
   #+end_src
* GCD and LCM
  #+begin_src python
def gcd(x, y):
    while y > 0:
        x, y = y, x % y
    return x

def lcm(x, y):
    return x*y // gcd(x,y)

x = 10
y = 15

gcdRet = gcd(x,y)
print(f"gcd({x},{y}) = {gcdRet}") # gcd(10,15) = 5
lcmRet = lcm(x,y)
print(f"lcm({x},{y}) = {lcmRet}") # lcm(10,15) = 30
  #+end_src
* tortoise & hare
  #+begin_src python
class Solution:
    def findDuplicate(self, nums):
        # Find the intersection point of the two runners.
        tortoise = nums[0]
        hare = nums[0]
        while True:
            # print "tortoise: %d, hare: %d" % (tortoise, hare)
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            # print "tortoise: %d, hare: %d" % (tortoise, hare)
            if tortoise == hare:
                break
        # Find the "entrance" to the cycle.
        ptr1 = nums[0]
        ptr2 = tortoise
        while ptr1 != ptr2:
            ptr1 = nums[ptr1]
            ptr2 = nums[ptr2]
        return ptr1
  #+end_src
* Sliding window
  Sliding Window Technique is a method for finding subarrays in an array that satisfy given conditions.
  We do this via maintaining a subset of items as our window, and resize and move that window within the larger list until we find a solution.
  Sliding Window Technique is a subset of Dynamic Programming, and it frequently appears in algorithm interviews.

  Examples:
- Easy: Statically Sized Sliding Window: Given an array of integers, find maximum/minimum sum subarray of the required size.
- Medium: Dynamically Sized Sliding Window: Given an array of positive integers, find the subarrays that add up to a given number.
- Variation (Medium): Same question but for an array with all integers (positive, 0, negative). The optimal solution is Kadane’s Algorithm, but Sliding Window can still be applied with modifications (not recommended though).
- Medium: Flipping/Swapping: Given an array of 0’s and 1’s, find the maximum sequence of continuous 1’s that can be formed by flipping at-most k 0’s to 1’s.
- Hard: Strings: Given a string and n characters, find the shortest substring that contains all the desired characters.

  #+begin_src python
    # Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.
    # Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
    # Output: 6
    # Explanation: [1,1,1,0,0,1,1,1,1,1,1]
    # Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
    class Solution:
	def longestOnes(self, nums: List[int], k: int) -> int:
	    left = 0
	    for right in range(len(nums)):
		# If we included a zero in the window we reduce the value of k.
		# Since k is the maximum zeros allowed in a window.
		k -= 1 - nums[right]
		# A negative k denotes we have consumed all allowed flips and window has
		# more than allowed zeros, thus increment left pointer by 1 to keep the window size same.
		if k < 0:
		    # If the left element to be thrown out is zero we increase k.
		    k += 1 - nums[left]
		    left += 1
	    return right - left + 1

  #+end_src
Links:
 - https://quanticdev.com/algorithms/dynamic-programming/sliding-window/
 - https://leetcode.com/problems/max-consecutive-ones-iii
* Line sweep
  It's very useful to solve those {startTime, stopTime} pair problem.
   - create a list l which is a range of from minStartTime to  maxStopTime
   - scan each time point, found startTime, l[startTime] += 1, found stopTime, l[stopTime] -= 1, with that we know in each time point, what's the delta of events
  #+begin_src python
    # 
    class Solution:
	def maximumPopulation(self, logs: List[List[int]]) -> int:
	    pop = [0] * 2051
	    res = 0
	    for log in logs:
		pop[log[0]] += 1
		pop[log[1]] -= 1
	    for i in range(1950, 2051):
		pop[i] += pop[i-1]
		if pop[i] > pop[res]:
		    res = i
	    return res
  #+end_src
  - https://leetcode.com/problems/maximum-population-year/
* Heap

  scenarios:
   - top K ordered items
   - two-heaps pattern,  where we are given a set of elements such that we can divide them into two parts, To be able to solve these kinds of problems, we want to know the smallest element in one part and the biggest element in the other part.
     - https://emre.me/coding-patterns/two-heaps/

  Notes:
  - python default heap is minHeap
  - C++ default heap is maxHeap

  
  #+begin_src cpp
    class Solution {
    public:
	int findKthLargest(vector<int>& nums, int k) {
            // using minHeap here
	    priority_queue<int, vector<int>, greater<int>> pq;
	    for (int num : nums) {
		pq.push(num);
		if (pq.size() > k) {
		    pq.pop();
		}
	    }
	    return pq.top();
	}
    };
  #+end_src
  #+begin_src python
def findKthLargest(self, nums, k):
    heap = nums[:k]
    heapify(heap)
    for n in nums[k:]:  heappushpop(heap, n)
    return heap[0]
  #+end_src

  #+begin_src python
class Solution:
    def minMeetingRooms(self, intervals):
        intervals.sort(key=lambda x:x[0])
        heap = []  # stores the end time of intervals
        for i in intervals:
            if heap and i[0] >= heap[0]: 
                # means two intervals can use the same room
                heapq.heapreplace(heap, i[1])
            else:
                # a new room is allocated
                heapq.heappush(heap, i[1])
        return len(heap)

  #+end_src
  #+begin_src python
from heapq import *

class MedianFinder:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.small = []
        self.large = []
        # heapq.heapify(self.small)
        # heapq.heapify(self.large)
        

    def addNum(self, num: int) -> None:
        heapq.heappush(self.small,num)
        tmp = heapq.heappop(self.small)
        heapq.heappush(self.large, -1 * tmp)
        if len(self.large) > len(self.small):
            tmp = heapq.heappop(self.large)
            heapq.heappush(self.small, -1 * tmp)
        

    def findMedian(self) -> float:
        if len(self.large) == len(self.small):
            return (-1 * self.large[0] + self.small[0]) / 2
        else:
            return self.small[0]
  #+end_src
  
  - https://leetcode.com/problems/find-median-from-data-stream/
  - https://leetcode.com/problems/meeting-rooms-ii/
* Binary Search
  #+begin_src c++
    vector<int> searchRange(vector<int>& nums, int target) {
	 return {findBound(nums, target, true), findBound(nums, target, false)};
    }

     int findBound(vector<int>& nums, int target, bool lower) {
	 int l = 0, r = nums.size() - 1, answer = -1;

	 while(l <= r) {
	     int mid = (l+r)/2;
	     if (nums[mid] == target) {
		 answer = mid; // keep the current answer as you mignt not be able to comback if this was the answer.
		 if (lower) {
		     r = mid - 1;
		 } else {
		     l = mid + 1;
		 }
	     } else if (nums[mid] > target) {
		 r = mid - 1;
	     } else {
		 l = mid + 1;
	     }
	 }

	 return answer;
     }
  #+end_src
  #+begin_src python
import bisect

# bisect_left(a, x, lo=0, hi=None)
# This method returns the index i where must be inserted the value x such that list a is kept ordered
a = [1, 3, 5, 6, 7, 9, 10, 12, 14]
x = 8
# i = bisect.bisect_left(a, x, lo=2, hi=7) # [5, 6, 7, 9, 10]
i = bisect.bisect_left(a, x)
print(i) # 5
a.insert(i, x)
print(a) # [1, 3, 5, 6, 7, 8, 9, 10, 12, 14]

# bisect_right(a, x, lo=0, hi=None)
# This function works the same as bisect_left but in the event that x value already appears in the a list , the index i would be just after the rightmost x value already there.
a = [1, 2, 3, 4, 4, 7]
x = 4
i = bisect.bisect_right(a, x)
print(i) # 5

a.insert(i, x)
print(a) # [1, 2, 3, 4, 4, 4, 7]
  #+end_src
   - https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
* Rolling Hash
  #+begin_src c++
    class Solution {
    public:
	string longestPrefix(string &s) {
	    long h1 = 0, h2 = 0, mul = 1, len = 0, mod = 1000000007;
	    for (int i = 0, j = s.length() - 1; j > 0; ++i, --j) {
		int first = s[i] - 'a', last = s[j] - 'a';
		h1 = (h1 * 26 + first) % mod;
		h2 = (h2 + mul * last) % mod;
		mul = mul * 26 % mod;
		if (h1 == h2)
		    len = i + 1;
	    }
	    return s.substr(0, len);
	}
    };

  #+end_src
  #+begin_src python
    class Solution(object):
	def longestPrefix(self, s):
	    hashF = hashB = 0
	    code = 32
	    mod = int(1e9 + 7)

	    l = 0
	    mul = 1
	    for i in range(len(s) - 1):
		hashF = (hashF * code + ord(s[i])) % mod
		hashB = (hashB + ord(s[~i]) * mul) % mod
		mul = (mul * code) % mod
		if hashF == hashB:
		    l = i + 1
	    return s[:l]

  #+end_src
  - https://leetcode.com/problems/longest-happy-prefix/
* Stack
  #+begin_src python
class Solution:
    # @return a boolean
    def isValid(self, s):
        stack = []
        dict = {"]":"[", "}":"{", ")":"("}
        for char in s:
            if char in dict.values():
                stack.append(char)
            elif char in dict.keys():
                if stack == [] or dict[char] != stack.pop():
                    return False
            else:
                return False
        return stack == []
  #+end_src
  - https://leetcode.com/problems/valid-parentheses/

* Monotonic stack
  
  #+begin_src python
class Solution:
    def trap(self, height: List[int]) -> int:
        res, stk = 0, []
        for i in range(len(height)):
            while stk and height[i] > height[stk[-1]]:
                h = height[stk.pop()]
                if stk:
                    minH = min(height[stk[-1]], height[i])
                    res += (minH - h) * (i - stk[-1] - 1)
            stk.append(i)
        return res
  #+end_src
  - https://leetcode.com/problems/largest-rectangle-in-histogram/
  - https://leetcode.com/problems/trapping-rain-water/
* Queue  

* Robot Bounded In Circle
  It's said to be used by Amazon very often
  #+begin_src python
    class Solution(object):
	def isRobotBounded(self, instructions):
	    """
	    :type instructions: str
	    :rtype: bool
	    """

	    di = (0,1)
            # G -> (0,1), L -> (-1,0), R -> (1,0)
	    x,y = 0,0
	    for instruction in instructions:
		if instruction == 'G':
		    x,y = x+di[0],y+di[1]
		elif instruction == 'L':
		    di = (-di[1],di[0]) # very smart way to change direction
		else:
		    di = (di[1],-di[0])
	    return (x==0 and y==0) or di!=(0,1)
  #+end_src
   - https://leetcode.com/problems/robot-bounded-in-circle/
* Monotonic queue

* Tree traverse
  - https://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/?ref=lbp
  - 
* Trie Tree
  #+begin_src bash
    A trie (pronounced as "try") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.
    There are various applications of this data structure, such as autocomplete and spellchecker.

    Implement the Trie class:

    Trie() Initializes the trie object.
    void insert(String word) Inserts the string word into the trie.
    boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.
    boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.
  #+end_src


  #+begin_src python
class TrieNode:
    # Initialize your data structure here.
    def __init__(self):
        self.children = collections.defaultdict(TrieNode)
        self.is_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    def insert(self, s):
        curr = self.root
        for i in s:
            curr = curr.children[i]
        curr.is_word = True
    def search(self, s):
        curr = self.root
        for i in s:
            if i in curr.children:
                curr = curr.children[i]
            else:
                return False
        return curr.is_word

    def startsWith(self,s):
        curr = self.root
        for i in s:
            if i in curr.children:
                curr = curr.children[i]
            else:
                return False
        return True
  #+end_src
  #+begin_src c++
class Trie {
public:
    Trie() {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            if (!node->next.count(ch)) { node->next[ch] = new Trie(); }
            node = node->next[ch];
        }
        node->isword = true;
    }

    bool search(string word) {
        Trie* node = this;
        for (char ch : word) {
            if (!node->next.count(ch)) { return false; }
            node = node->next[ch];
        }
        return node->isword;
    }

    bool startsWith(string prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            if (!node->next.count(ch)) { return false; }
            node = node->next[ch];
        }
        return true;
    }

private:
    map<char, Trie*> next = {};
    bool isword = false;
};
  #+end_src
   - https://leetcode.com/problems/implement-trie-prefix-tree/submissions/

* Segment Tree
  #+begin_src python
#Segment tree node
class Node(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.total = 0
        self.left = None
        self.right = None

class NumArray(object):
    def __init__(self, nums):
        """
        initialize your data structure here.
        :type nums: List[int]
        """
        #helper function to create the tree from input array
        def createTree(nums, l, r):
            #base case
            if l > r:
                return None
            #leaf node
            if l == r:
                n = Node(l, r)
                n.total = nums[l]
                return n
            mid = (l + r) // 2
            root = Node(l, r)
            #recursively build the Segment tree
            root.left = createTree(nums, l, mid)
            root.right = createTree(nums, mid+1, r)
            
            #Total stores the sum of all leaves under root
            #i.e. those elements lying between (start, end)
            root.total = root.left.total + root.right.total
            return root
        self.root = createTree(nums, 0, len(nums)-1)
            
    def update(self, i, val):
        """
        :type i: int
        :type val: int
        :rtype: int
        """
        #Helper function to update a value
        def updateVal(root, i, val):
            #Base case. The actual value will be updated in a leaf.
            #The total is then propogated upwards
            if root.start == root.end:
                root.total = val
                return val
            mid = (root.start + root.end) // 2
            #If the index is less than the mid, that leaf must be in the left subtree
            if i <= mid:
                updateVal(root.left, i, val)
            #Otherwise, the right subtree
            else:
                updateVal(root.right, i, val)
            #Propogate the changes after recursive call returns
            root.total = root.left.total + root.right.total
            
            return root.total
        
        return updateVal(self.root, i, val)

    def sumRange(self, i, j):
        """
        sum of elements nums[i..j], inclusive.
        :type i: int
        :type j: int
        :rtype: int
        """
        #Helper function to calculate range sum
        def rangeSum(root, i, j):
            #If the range exactly matches the root, we already have the sum
            if root.start == i and root.end == j:
                return root.total
            mid = (root.start + root.end) // 2
            #If end of the range is less than the mid, the entire interval lies
            #in the left subtree
            if j <= mid:
                return rangeSum(root.left, i, j)
            #If start of the interval is greater than mid, the entire inteval lies
            #in the right subtree
            elif i >= mid + 1:
                return rangeSum(root.right, i, j)
            #Otherwise, the interval is split. So we calculate the sum recursively,
            #by splitting the interval
            else:
                return rangeSum(root.left, i, mid) + rangeSum(root.right, mid+1, j)
        return rangeSum(self.root, i, j)

# Your NumArray object will be instantiated and called as such:
# numArray = NumArray(nums)
# numArray.sumRange(0, 1)
# numArray.update(1, 10)
# numArray.sumRange(1, 2)
  #+end_src
   - https://leetcode.com/problems/range-sum-query-mutable/
* Binary index tree （树状数组)
  It's also named as Fenwick tree
  Doing similar work as segment tree, less code, both are good at rangeSum and rangeQuery
  The idea to create a array bit, bit[x] store the sum of bit[x-lowBit(x)+1,x] inclusive.
  please notice, bit is using 1-based indexing
  - [[https://blog.csdn.net/bestsort/article/details/80796531?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-3.queryctrv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-3.queryctrv2&utm_relevant_index=6][About binary index tree]]
  - https://www.youtube.com/watch?v=RgITNht_f4Q
  #+begin_src python
    def lowBit(n):
	return n & (-n)
    class BIT:
	def __init__(self, size):
	    self.bit = [0] * (size + 1)

	def getSum(self, idx):  # Get sum in range [1..idx], 1-based indexing
	    s = 0
	    while idx > 0:
		s += self.bit[idx]
		idx -= lowBit(idx)
	    return s 

	def getSumRange(self, left, right):  # left, right inclusive, 1-based indexing
	    return self.getSum(right) - self.getSum(left - 1)

	def addValue(self, idx, val):  # 1-based indexing
	    while idx < len(self.bit):
		self.bit[idx] += val
		idx += lowBit(idx)

    class NumArray:

	def __init__(self, nums: List[int]):
	    self.nums = nums
	    self.bit = BIT(len(nums))
	    for i, v in enumerate(nums):
		self.bit.addValue(i+1, v)

	def update(self, index: int, val: int) -> None:
	    diff = val - self.nums[index]  # get diff amount of `val` compared to current value
	    self.bit.addValue(index+1, diff)  # add this `diff` amount at index `index+1` of BIT, plus 1 because in BIT it's 1-based indexing
	    self.nums[index] = val # update latest value of `nums[index]`

	def sumRange(self, left: int, right: int) -> int:
	    return self.bit.getSumRange(left+1, right+1)
  #+end_src
   - https://leetcode.com/problems/range-sum-query-mutable/discuss/1406686/C%2B%2BJavaPython-Binary-Indexed-Tree
   - https://zhuanlan.zhihu.com/p/92920381
* Union Find
  
  #+begin_src python
    # Idea: find minimal edges to make graph fully traversable
    # - we can use union-find here, we will have 2 union here, one for Alice, one for Bob
    # - because type 3 may add travese for both Alice and Boby, so we will pick such edges firstly
    # - every time while we pick one edge, we update the union, also update the requiredEdgeNum, if both node of this edge alread in union, we don't need add this edge
    # - At the end we check if both union are fully connected, if yes, the answer is len(edges) - requiredEdgeNum
    class UnionFind:
	def __init__(self,n):
	    self.distinct_component_num = n
	    self.components = list(range(n+1))
	def union(self,i,j):
	    if self.find(i) == self.find(j):
		return False
	    else:
		self.components[self.find(i)] = j
		self.distinct_component_num -= 1
		return True
    
	def find(self,i):
	    if i == self.components[i]:
		return i
	    else:
		self.components[i] = self.find(self.components[i])
		return self.components[i]
    
	def connected(self):
	    return self.distinct_component_num == 1
        
    class Solution:
	def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
	    required_edge_num = 0
	    edges.sort(key=lambda x:x[0], reverse = True)
	    alice = UnionFind(n)
	    bob = UnionFind(n)
	    for e in edges:
		if e[0] == 3:
		    tmp1 = alice.union(e[1],e[2])  
		    tmp2 = bob.union(e[1],e[2])
		    if tmp1 or tmp2:
			required_edge_num += 1
		elif e[0] == 2:
		    if bob.union(e[1],e[2]):
			required_edge_num += 1
		elif e[0] == 1:
		    if alice.union(e[1],e[2]):
			required_edge_num += 1
	    if alice.connected() and bob.connected():
		return len(edges) - required_edge_num
	    else:
		return -1
  #+end_src

  #+begin_src python
    # a graph is a valid tree only if len(edges) == n-1 and no cycle
    def validTree(self, n, edges):
	parent = list(range(n))
	def find(x):
	    return x if parent[x] == x else find(parent[x])
	def union(xy): # xy is a list of x and y
	    x, y = map(find, xy)
	    parent[x] = y
	    return x != y
	return len(edges) == n-1 and all(map(union, edges))
  #+end_src
 - https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/
 - https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/
 - https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii/
* DFS
  #+begin_src python
    # 797. All Paths From Source to Target
    class Solution:
	def allPathsSourceTarget(self, graph):
	    def dfs(cur, path):
		if cur == len(graph) - 1: res.append(path)
		else:
		    for i in graph[cur]: 
			dfs(i, path + [i])
	    res = []
	    dfs(0, [0])
	    return res
  #+end_src
  #+begin_src python
class Solution:
    def numIslands(self, grid):
        if not grid:
            return 0

        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1':
                    self.dfs(grid, i, j)
                    count += 1
        return count

    def dfs(self, grid, i, j):
        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
            return
        grid[i][j] = '#'
        self.dfs(grid, i+1, j)
        self.dfs(grid, i-1, j)
        self.dfs(grid, i, j+1)
        self.dfs(grid, i, j-1)
  #+end_src

  
 - https://leetcode.com/problems/number-of-islands/
* BFS
  #+begin_src python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        q = deque([root])
        ret = []
        level = 0
        while len(q) > 0:
            sz = len(q)
            current = [-1] * sz
            for i in range(0,sz):
                node = q.popleft()
                if level % 2 == 0:
                    current[i] = node.val
                else:
                    current[sz-i-1] = node.val
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
            level += 1
            ret.append(current)
        return ret    
  #+end_src
  - https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
* Sort

Sort 2D array
   #+begin_src cpp
     vector<vector<int>>& edges;
     sort(begin(edges), end(edges),
	  [](vector<int>& a, vector<int>& b) { return a[0] > b[0]; });
   #+end_src

   #+begin_src python
     edges: List[List[int]]
     edges.sort(key:lambda x: x[0], reverse=False)
   #+end_src

   More python example:
#+begin_src python
  l = [[1,2,3],[3,4,6,],[2,4,5],[2,101,5],[2,34,1]]
  l.sort(key=lambda x: (x[0],x[1]), reverse=True)
  print(l)


  students= [['Harry', 37.21], ['Berry', 37.21], ['Tina', 37.2], ['Akriti', 41.0], ['Harsh', 39.0]]

  def compare(e):
    return (e[1],e[0])

  students = sorted(students,key=compare)
  print(students)


  # task: sort the list of strings, such that items listed as '_fw' come before '_bw'
  foolist = ['Goo_fw', 'Goo_bw', 'Foo_fw', 'Foo_bw', 'Boo_fw', 'Boo_bw']

  def sortfoo(s):
      s1, s2 = s.split('_')
      r = 1 if s2 == 'fw' else 2     # forces 'fw' to come before 'bw'
      return (r, s1)                 # order first by 'fw'/'bw', then by name

  foolist.sort(key=sortfoo)          # sorts foolist inplace

  print(foolist)
  # prints:
  # ['Boo_fw', 'Foo_fw', 'Goo_fw', 'Boo_bw', 'Foo_bw', 'Goo_bw']

class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        r = Counter(nums)
        return sorted(nums, key=lambda x: (r[x], -x))
#+end_src
* Topology sort
  #+begin_src python
class Solution:    
    def findOrder(self, N,P):
        graph = defaultdict(list)
        indegree = [0] * N
        q = deque()
        ans = []
        for nxt, pre in P:
            graph[pre].append(nxt)
            indegree[nxt] += 1
        for i in range(N):
            if indegree[i] == 0:
                q.append(i)
        while q:
            cur = q.popleft()
            ans.append(cur)
            for nxt in graph[cur]:
                indegree[nxt] -= 1
                if indegree[nxt] == 0:
                    q.append(nxt)
        return ans if len(ans) == N else []
  #+end_src
  - https://leetcode.com/problems/course-schedule/
  - https://leetcode.com/problems/course-schedule-ii/
  
* DP
  #+begin_src python
class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:        
        events.sort()
        starts = [x for x,y,z in events]
        
        @lru_cache(None)
        def dp(idx, k):
            if k == 0 or idx >= len(events):
                return 0
            next_event = bisect_right(starts, events[idx][1])
            return max(dp(idx+1, k), events[idx][2] + dp(next_event, k-1))
    
        return dp(0,k)
  #+end_src

  #+begin_src python
class Solution(object):
    def wordBreak(self, s, words):
        dp = [True] + [False] * len(s)
        for i in range(1, len(s)+1):
            for j in range(i):
                if dp[j] and s[j:i] in words:
                    dp[i] = True
        return dp[-1]

  #+end_src
  - https://leetcode.com/problems/word-break/
  - https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/
  - https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/
* Backtracking
  #+begin_src python
#Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
class Solution(object):
    def permute(self, l):
        if len(l) == 0:
            return [[]]
        permuations = []
        curr = []
        isVisited = [False] * len(l)
        self.backTracking(permuations, curr, isVisited, l)
        return permuations

    def backTracking(self, permuations,  curr, isVisited, l):
        if len(curr) == len(l):
            permuations.append(curr[:])
            return

        for i in range(len(l)):
            if not isVisited[i]:
                isVisited[i] = True
                curr.append(l[i])
                self.backTracking(permuations, curr, isVisited, l)
                isVisited[i] = False
                curr.pop()
  #+end_src
  #+begin_src python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result=[]
        def backtrack(nums, start, path):
            result.append(path[:])
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(nums,i+1,path)
                path.pop()
        backtrack(nums, 0, [])
        return result
  #+end_src
   - https://leetcode.com/problems/permutations/submissions/
   - https://leetcode.com/problems/word-search-ii/
   - https://leetcode.com/problems/subsets/
* Standard parser implementation
  #+begin_src python
class Solution:
    # Standard parser implementation based on this BNF
    #   s := expression
    #   expression := term | term { [+,-] term] }
    #   term := factor | factor { [*,/] factor] }
    #   factor :== digit | '(' expression ')'
    #   digit := [0..9]
    
    def expTree(self, s: str) -> 'Node':
        tokens = collections.deque(list(s))
        return self.parse_expression(tokens)

    def parse_expression(self, tokens):
        lhs = self.parse_term(tokens)
        while len(tokens) > 0 and tokens[0] in ['+', '-']:
            op = tokens.popleft()
            rhs = self.parse_term(tokens)
            lhs = Node(val=op, left=lhs, right=rhs)
        return lhs
    
    def parse_term(self, tokens):
        lhs = self.parse_factor(tokens)
        while len(tokens) > 0 and tokens[0] in ['*', '/']:
            op = tokens.popleft()
            rhs = self.parse_factor(tokens)
            lhs = Node(val=op, left=lhs, right=rhs)
        return lhs

    def parse_factor(self, tokens):
        if tokens[0] == '(':
            tokens.popleft() # consume '('
            node = self.parse_expression(tokens)
            tokens.popleft() # consume ')'
            return node
        else:
            # Single operand
            token = tokens.popleft()
            return Node(val=token)
  #+end_src
  - https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/
* Prim algorithm (To find minimum spanning tree)
  #+begin_src python
class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        manhattan = lambda p1, p2: abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
        n, c = len(points), collections.defaultdict(list)
        # create the graph with cost in each edges
        for i in range(n):
            for j in range(i+1, n):
                d = manhattan(points[i], points[j])
                c[i].append((d, j))
                c[j].append((d, i))
        # start from point 0
        cnt, ans, visited, heap = 1, 0, [0] * n, c[0]
        visited[0] = 1
        # the reason to use heap is to get the smaller cost another node
        heapq.heapify(heap)
        while heap:
            d, j = heapq.heappop(heap)
            if not visited[j]:
                visited[j], cnt, ans = 1, cnt+1, ans+d
                for record in c[j]: heapq.heappush(heap, record)
            if cnt >= n: break
        return ans
  #+end_src
  - https://leetcode.com/problems/min-cost-to-connect-all-points/
* Kluskal algorithm (To find minimun spanning tree)
  #+begin_src python
class UnionFind:
    def __init__(self, n):
        self.parent = [i for i in range(n)]

    def find(self, u):
        if u != self.parent[u]:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        pu, pv = self.find(u), self.find(v)
        if pu == pv: return False
        self.parent[pu] = pv
        return True


class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        def manhattanDist(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

        edges = []
        n = len(points)
        for i in range(n):
            for j in range(i + 1, n):
                edges.append([manhattanDist(points[i], points[j]), i, j])

        edges.sort()  # Sort increasing order by dist
        uf = UnionFind(n)
        ans = 0
        for d, u, v in edges:
            if uf.union(u, v):
                ans += d
                n -= 1
            if n == 1: break  # a bit optimize when we found enough n-1 edges!
        return ans
  #+end_src
    - https://leetcode.com/problems/min-cost-to-connect-all-points/
* multiple threading
  #+begin_src python
from threading import Lock

class Foo:
    def __init__(self):
        self.locks = (Lock(),Lock())
        self.locks[0].acquire()
        self.locks[1].acquire()
        
    def first(self, printFirst):
        printFirst()
        self.locks[0].release()
        
    def second(self, printSecond):
        with self.locks[0]:
            printSecond()
            self.locks[1].release()
            
            
    def third(self, printThird):
        with self.locks[1]:
            printThird()
  #+end_src

  #+begin_src python
'''
There are two kinds of threads: oxygen and hydrogen. Your goal is to group these threads to form water molecules.

This solution uses Semaphore and Barrier. It is simple to understand, and performs well.

Semantics
a Semaphore -- trying to acquire it, is possible if there are tokens left. Otherwise the thread that tried is asked to wait until a different thread returns the tokens it was using.
a Barrier -- if a thread reaches it, it can cross it, only if a predefined number of other threads have also arrived.
Logic
The solution creates 1 Semaphore for Hydrogen, and allows 2 threads to aquire it concurrently. Likewise, we create one for Oxygen, but this one only allows 1 thread.

To ensure the molecule is generated at once, we use a barrier, which can only be crossed when 3 atoms have gathered.

After each function completes, we release the token on the Semaphore.
'''

from threading import Semaphore
from threading import Barrier

class H2O:
    def __init__(self):
        self.sem_h = Semaphore(2)
        self.sem_o = Semaphore(1)
        self.bar_assembling = Barrier(3)

    def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -> None:
        with self.sem_h:
            self.bar_assembling.wait()
            releaseHydrogen()
    def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:
        with self.sem_o:
            self.bar_assembling.wait()
            releaseOxygen()
  #+end_src
#+begin_src python
from concurrent import futures

class Solution:
    def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> List[str]:
        hostname = lambda url: url.split('/')[2]
        seen = {startUrl}
    
        with futures.ThreadPoolExecutor(max_workers=16) as executor:
            tasks = deque([executor.submit(htmlParser.getUrls, startUrl)])
            while tasks:
                for url in tasks.popleft().result():
                    if url not in seen and hostname(startUrl) == hostname(url):
                        seen.add(url)
                        tasks.append(executor.submit(htmlParser.getUrls, url))
        
        return list(seen)
#+end_src
** dead lock
   A deadlock is a situation in which processes block each other due to resource acquisition and none of the processes makes any progress as they wait for the resource held by the other process.
   To successfully characterize a scenario as deadlock, the following four conditions must hold simultaneously:

    - Mutual Exclusion: At least one resource needs to be held by a process in a non-sharable mode. Any other process requesting that resource needs to wait.
    - Hold and Wait: A process must hold one resource and requests additional resources that are currently held by other processes.
    - No Preemption: A resource can’t be forcefully released from a process. A process can only release a resource voluntarily once it deems to release.
    - Circular Wait: A set of a process {p0, p1, p2,.., pn} exists in a manner that p0 is waiting for a resource held by p1, pn-1 waiting for a resource held by p0.
** live lock
   In the case of a livelock, the states of the processes involved in a live lock scenario constantly change. On the other hand, the processes still depend on each other and can never finish their tasks.

** Starvation
   Starvation is an outcome of a process that is unable to gain regular access to the shared resources it requires to complete a task and thus, unable to make any progress.

   One of the possible solutions to prevent starvation is to use a resource scheduling algorithm with a priority queue that also uses the aging technique. Aging is a technique that periodically increases the priority of a waiting process. With this approach, any process waiting for a resource for a longer duration eventually gains a higher priority. And as the resource sharing is driven through the priority of the process, no process starves for a resource indefinitely.

   Another solution to prevent starvation is to follow the round-robin pattern while allocating the resources to a process. In this pattern, the resource is fairly allocated to each process providing a chance to use the resource before it is allocated to another process again.

** Race condition
   When two processes are competing with each other causing data corruption
** Vmware questions
    - What's the diffrence between mutex and spinlock?
      - mutex will sleep for waiting
      - spinlock will keep trying (busy waiting)
      - mutex need do context switch
      - spinlock doesn't do context switch
      - using spinlock , we should keep the protected area code very simple and running fast, otherwise ,it may occupy a lot of cpu
    - Can you talk about condition variable
      - condition variable always comes with a lock and a condtion checking monitor
      - condition variable support notify, so once some state chane, we can we can notify condition vaiable, and it will recheck the condition 
   
   - https://leetcode.com/problems/design-bounded-blocking-queue/
   - https://leetcode.com/problemset/concurrency/
   - https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation
   - https://www.baeldung.com/cs/deadlock-livelock-starvation
   - https://leetcode.com/problems/fizz-buzz-multithreaded/discuss/542960/python-greater99.28-a-standard-Lock()-based-solution-with-detailed-explanation
   - https://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex
   - https://hackernoon.com/synchronization-primitives-in-python-564f89fee732
* System design template
  #+begin_src
(1) FEATURE EXPECTATIONS [5 min]
        (1) Use cases
        (2) Scenarios that will not be covered
        (3) Who will use
        (4) How many will use
        (5) Usage patterns
(2) ESTIMATIONS [5 min]
        (1) Throughput (QPS for read and write queries)
        (2) Latency expected from the system (for read and write queries)
        (3) Read/Write ratio
        (4) Traffic estimates
                - Write (QPS, Volume of data)
                - Read  (QPS, Volume of data)
        (5) Storage estimates
        (6) Memory estimates
                - If we are using a cache, what is the kind of data we want to store in cache
                - How much RAM and how many machines do we need for us to achieve this ?
                - Amount of data you want to store in disk/ssd
(3) DESIGN GOALS [5 min]
        (1) Latency and Throughput requirements
        (2) Consistency vs Availability  [Weak/strong/eventual => consistency | Failover/replication => availability]
(4) HIGH LEVEL DESIGN [5-10 min]
        (1) APIs for Read/Write scenarios for crucial components
        (2) Database schema
        (3) Basic algorithm
        (4) High level design for Read/Write scenario
(5) DEEP DIVE [15-20 min]
        (1) Scaling the algorithm
        (2) Scaling individual components: 
                -> Availability, Consistency and Scale story for each component
                -> Consistency and availability patterns
        (3) Think about the following components, how they would fit in and how it would help
                a) DNS
                b) CDN [Push vs Pull]
                c) Load Balancers [Active-Passive, Active-Active, Layer 4, Layer 7]
                d) Reverse Proxy
                e) Application layer scaling [Microservices, Service Discovery]
                f) DB [RDBMS, NoSQL]
                        > RDBMS 
                            >> Master-slave, Master-master, Federation, Sharding, Denormalization, SQL Tuning
                        > NoSQL
                            >> Key-Value, Wide-Column, Graph, Document
                                Fast-lookups:
                                -------------
                                    >>> RAM  [Bounded size] => Redis, Memcached
                                    >>> AP [Unbounded size] => Cassandra, RIAK, Voldemort
                                    >>> CP [Unbounded size] => HBase, MongoDB, Couchbase, DynamoDB
                g) Caches
                        > Client caching, CDN caching, Webserver caching, Database caching, Application caching, Cache @Query level, Cache @Object level
                        > Eviction policies:
                                >> Cache aside
                                >> Write through
                                >> Write behind
                                >> Refresh ahead
                h) Asynchronism
                        > Message queues
                        > Task queues
                        > Back pressure
                i) Communication
                        > TCP
                        > UDP
                        > REST
                        > RPC
(6) JUSTIFY [5 min]
	(1) Throughput of each layer
	(2) Latency caused between each layer
	(3) Overall latency justification
  #+end_src
  
* Leetcode template
  #+begin_src bash
If input array is sorted then
    - Binary search
    - Two pointers

If asked for all permutations/subsets then
    - Backtracking

If given a tree then
    - DFS
    - BFS

If given a graph then
    - DFS
    - BFS

If given a linked list then
    - Two pointers

If recursion is banned then
    - Stack

If must solve in-place then
    - Swap corresponding values
    - Store one or more different values in the same pointer

If asked for maximum/minimum subarray/subset/options then
    - Dynamic programming

If asked for top/least K items then
    - Heap

If asked for common strings then
    - Map
    - Trie

Else
    - Map/Set for O(1) time & O(n) space
    - Sort input for O(nlogn) time and O(1) space
  #+end_src
* Links
  - https://emre.me/categories/#coding-patterns
  - https://github.com/seanprashad/leetcode-patterns
  - https://seanprashad.com/leetcode-patterns/


  


